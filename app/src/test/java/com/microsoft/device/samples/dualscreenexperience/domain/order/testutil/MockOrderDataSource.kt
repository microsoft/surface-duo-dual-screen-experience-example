/*
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 *
 */

package com.microsoft.device.samples.dualscreenexperience.domain.order.testutil

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import com.microsoft.device.samples.dualscreenexperience.data.order.OrderDataSource
import com.microsoft.device.samples.dualscreenexperience.data.order.model.OrderEntity
import com.microsoft.device.samples.dualscreenexperience.data.order.model.OrderItemEntity
import com.microsoft.device.samples.dualscreenexperience.data.order.model.OrderWithItems
import com.microsoft.device.samples.dualscreenexperience.domain.order.model.OrderItem

class MockOrderDataSource : OrderDataSource {
    private var orderEntityMap = mutableMapOf<Long, OrderEntity>()
    private var orderItemEntityMap = mutableMapOf<Long, OrderItemEntity>()
    private var orderWithItemsEntityMap = mutableMapOf<Long, OrderWithItems>()

    var autogeneratedItemId = 0L
    var autogeneratedOrderId = 0L

    private val currentOrderLiveData = MutableLiveData<OrderWithItems?>()

    override suspend fun getAll(): List<OrderWithItems> = orderWithItemsEntityMap.values.toList()

    override suspend fun getById(orderId: Long): OrderWithItems? = orderWithItemsEntityMap[orderId]

    override suspend fun insert(order: OrderEntity): Long {
        if (order.orderId == null) {
            autogeneratedOrderId += 1
            order.orderId = autogeneratedOrderId
        }
        orderEntityMap[order.orderId!!] = order
        orderWithItemsEntityMap[order.orderId!!] =
            OrderWithItems(
                order,
                orderItemEntityMap.values.filter { it.orderParentId == order.orderId!! }.toMutableList()
            )
        currentOrderLiveData.value = orderWithItemsEntityMap[order.orderId]
        return order.orderId!!
    }

    override suspend fun updateItem(itemId: Long, newQuantity: Int) {
        orderItemEntityMap.values.firstOrNull { it.itemId == itemId }?.apply {
            quantity = newQuantity
        }
        orderWithItemsEntityMap.values.flatMap { it.items }.firstOrNull { it.itemId == itemId }?.apply {
            quantity = newQuantity

            currentOrderLiveData.value = orderWithItemsEntityMap[orderParentId]
        }
    }

    override suspend fun insertItems(vararg items: OrderItemEntity) {
        items.forEach { item ->
            autogeneratedItemId += 1
            item.itemId = autogeneratedItemId

            item.orderParentId.let { orderId ->
                val sameItemInOrder =
                    orderWithItemsEntityMap[orderId]?.items
                        ?.firstOrNull { OrderItem(it) == OrderItem(item) }

                if (sameItemInOrder != null) {
                    sameItemInOrder.itemId?.let { sameItemId ->
                        updateItem(sameItemId, sameItemInOrder.quantity.inc())
                    }
                } else {
                    orderItemEntityMap[item.itemId ?: autogeneratedItemId] = item
                    orderWithItemsEntityMap[orderId]?.items?.add(item)
                    currentOrderLiveData.value = orderWithItemsEntityMap[orderId]
                }
            }
        }
    }

    override suspend fun deleteItem(itemId: Long) {
        orderItemEntityMap.remove(itemId)
        orderWithItemsEntityMap.values.flatMap { it.items }.firstOrNull { it.itemId == itemId }?.apply {
            orderWithItemsEntityMap.values.firstOrNull { it.order.orderId == orderParentId }?.items?.remove(this)

            currentOrderLiveData.value = orderWithItemsEntityMap[orderParentId]
        }
    }

    override fun getOrderBySubmitted(submitted: Boolean): LiveData<OrderWithItems?> =
        Transformations.map(currentOrderLiveData) { orderWithItems ->
            orderWithItems?.takeIf { it.order.isSubmitted == submitted }
        }
}
